# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer
import io
import pickle
import struct
import time
from os import system, name

import cv2
from os import error
from pathlib import Path
import threading, socket
from tkinter import *
from PIL import Image
import numpy
import pyautogui as pyautogui
from comp import CustomText
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path("./assets")


def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)


SERVER = '192.168.133.1'
PORT = 1212
ADDR = (SERVER, PORT)

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(ADDR)

def clear():
    # for windows
    if name == 'nt':
        _ = system('cls')
    # for mac and linux(here, os.name is 'posix')
    else:
        _ = system('clear')
class Client:
    def __init__(self):
        self.payload_size = struct.calcsize("Q")
    def gui(self):
        window = Tk()

        window.geometry("700x400")
        window.configure(bg="#F9F9F9")

        canvas = Canvas(
            window,
            bg="#F9F9F9",
            height=400,
            width=700,
            bd=0,
            highlightthickness=0,
            relief="ridge"
        )

        canvas.place(x=0, y=0)
        entry_image_1 = PhotoImage(
            file=relative_to_assets("entry_1.png"))
        entry_bg_1 = canvas.create_image(
            265.5,
            177.0,
            image=entry_image_1
        )
        self.entry_1 = Text(
            bd=0,
            bg="#BCBAB8",
            highlightthickness=0
        )
        self.entry_1.place(
            x=57.0,
            y=28.0,
            width=417.0,
            height=296.0
        )

        entry_image_2 = PhotoImage(
            file=relative_to_assets("entry_2.png"))
        entry_bg_2 = canvas.create_image(
            589.5,
            177.0,
            image=entry_image_2
        )
        self.entry_2 = Text(
            bd=0,
            bg="#BCBAB8",
            highlightthickness=0
        )
        self.entry_2.place(
            x=518.0,
            y=28.0,
            width=143.0,
            height=296.0
        )

        button_image_1 = PhotoImage(
            file=relative_to_assets("button_1.png"))
        button_1 = Button(
            image=button_image_1,
            borderwidth=0,
            highlightthickness=0,
            command=lambda: print("button_1 clicked"),
            relief="flat"
        )
        button_1.place(
            x=570.0,
            y=341.0,
            width=93.0,
            height=39.0
        )

        button_image_2 = PhotoImage(
            file=relative_to_assets("button_2.png"))
        button_2 = Button(
            image=button_image_2,
            borderwidth=0,
            highlightthickness=0,
            command=lambda: print("button_2 clicked"),
            relief="flat"
        )
        button_2.place(
            x=451.0,
            y=341.0,
            width=93.0,
            height=39.0
        )

        button_image_3 = PhotoImage(
            file=relative_to_assets("button_3.png"))
        stream = threading.Thread(target=self.stream)
        button_3 = Button(
            image=button_image_3,
            borderwidth=0,
            highlightthickness=0,
            command=lambda: stream.start(),
            relief="flat"
        )
        button_3.place(
            x=342.0,
            y=341.0,
            width=93.0,
            height=39.0
        )
        window.resizable(False, False)
        window.mainloop()

    def onModification(self, event):
        chars = event.widget.get("1.0", "end-1c")
        self.send_data(f'edit:{chars}')

    def sign_name(self, name):
        # the thread to receive messages
        rcv = threading.Thread(target=self.receive)
        rcv.start()
        self.send_data(f'name:{name}')

    # recieving data
    def receive(self):
        data = b""
        while True:
            while len(data) < self.payload_size:
                data += client.recv(819200)
            packed_msg_size = data[:self.payload_size]
            data = data[self.payload_size:]
            msg_size = struct.unpack("Q", packed_msg_size)[0]
            while len(data) < msg_size:
                data += client.recv(409600)
            message_data = data[:msg_size]
            data = data[msg_size:]
            message_decoded = pickle.loads(message_data)
            print(message_decoded)
            print(type(message_decoded))
            if "_io.BytesIO" in str(type(message_decoded)):
                img = Image.open(message_decoded)
                img_np = numpy.array(img)
                frame = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
                cv2.imshow("RECEIVING VIDEO", frame)
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
            else:
                pass
                    # print(message)
                    # handling incoming data
                    # if message.startswith('txt:'):
                    #     message = message[4:]
                    #     # self.entry_1.delete('1.0', END)
                    #     self.entry_1.replace('1.0', END, message)
                    # else:
                    #     message = '\n' + message
                    #     self.entry_2.insert(END, message)

    def send_data(self, message):
        client.sendall(self.pack(message))

    def pack(self, data):
        a = pickle.dumps(data)
        message = struct.pack("Q", len(a)) + a
        return message

    def stream(self):
        t = time.time()
        while True:
            img = pyautogui.screenshot()
            client.sendall(self.pack(img))
            print(f'FPS: {1 / (time.time() - t)}')
            clear()
            t = time.time()

g = Client()
t = threading.Thread(target=g.receive)
t.start()
g.gui()